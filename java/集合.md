
# 1.**ArrayList 和 LinkedList 的区别  以及和 Array 的区别**

类型;
**Array是基本数据结构**，可以存储基本类型数据或对象引用
ArrayList是Java集合框架中的一个类，实现了List接口，用于存储对象引用

大小可变性：
Array一但进行创建就不能进行改变
ArrayList可以进行动态改变，可以添加、删除、修改元素

性能：
访问元素时，Array快，因为是直接通过索引来查   
添加、删除元素时，ArrayList快，因为ArrayList底层是使用数组实现的

泛型支持：
Array可以是泛型的，也可以不是
ArrayList必须是


方法：
Array没有提供很多方法，比如添加、删除、修改元素等
ArrayList提供了很多方法，比如添加、删除、迭代元素等


# **ArrayList和LinkedList的区别：**

**数据结构：**（其实知道它的底层数据结构就能够分辨出其他的不同）
ArrayList底层是使用数组实现的
LinkedList底层是使用链表实现的

性能：
ArrayList在访问元素时，因为是通过索引来查，所以访问元素的速度比LinkedList快
LinkedList在添加、删除元素时，因为是通过链表来实现的，所以添加、删除元素的速度比ArrayList快

内存占用：
ArrayList在内存占用上比LinkedList少
因为LinkedList需要存储每个节点的指针

扩容：
ArrayList在扩容时，会创建一个新的数组，然后将原来的数组复制到新的数组中
LinkedList在扩容时，不需要创建新的数组，只需要创建新的节点，然后将原来的节点连接到新的节点上

功能：
ArrayList提供了更快的随机访问和更高效的内存来使用
LinkedList提供了更快的插入和删除操作


# 2.HashSet如何保证元素不重复？

（哈希算法，equals，hashCode）

基于哈希表来实现：
HashSet基于hashmap来实现存储元素的，用于存储**不允许重复的元素**、
每个存储在HashSet的元素作为key，对应的value是固定的Object对象（通常是一个私有的present对象）

# **使用hashcode和equals方法来判断元素是否相等：**

hashcode当HashSet添加元素时，会调用hashcode来获取元素的哈希值；
然后根据其来计算在哈希表中的存储位置（即桶的位置）

equals方法当确定存储位置，如果存在会调用equals方法来判断元素是否相等。
如果存在，则返回false，否则返回true



# **3.List接口和Set接口的区别：**

List是有序的，可以重复的
Set是无序的，不可以重复的
元素位置访问：
List可以通过索引来访问元素，Set不能通过索引来访问元素



# **4.hashmap了解吗？底层实现是什么？（底层数据结构）**

hashmap存储数据采用哈希表的结构
就是  **一维数组+单向链表+红黑树**  进行key-value数据的存储

**链表长度超过8**，数组长度超过**64**时，从单向链表改成红黑树
因为链表过长，查找效率会下降


当索引i位置上的元素的**个数低于6时**，将红黑树改成单向链表



# **5.hashmap的扩容机制？**

触发条件：
当hashmap中存储的键值对数超过阈值时，会进行扩容
阈值 = 容量 * 负载因子（通常为0.75）

扩容过程：
先创建新的，更大的数组，通常是原先的两倍
然后将原先的键值对复制到新的数组中去，重新计算索引值进行插入

目的：
减少哈希冲突：
通过扩大数组容量，使得更加均匀的分布，减少哈希冲突，保证查询效率
保持性能：
不扩容的话，链表和红黑树越来越大，性能会下降

简单来说：装不下-》 换新家 -》 造更大的家 -》 把旧家里的东西重新摆放在新家里



# 6.hashmap和hashtable的区别？

**线程安全性：**
hashmap非线程安全，hashtable线程安全

null值和null键：
hashmap：可以单个null键，多个null值
hashtable：不能有null键，不能有null值

性能：
hashmap非线程安全，所以在单线程中的性能会更高
hashtable线程安全，但是在方法同步，多线程开销较大，性能就会较低，

所以通常建议使用currentHashMap来代替hashtable




# 7.HashSet和hashmap的区别？

存储不同：
HashSet：存储不重复的元素，主要用来快速查询某个元素是否存在
HashMap：存储键值对，根据键快速查找对应的值

存储结构：
HashSet：底层是hashmap，所以存储的元素是键，值是固定的Object对象


# **8.treeMap和hashmap的区别？**

hashmap基于哈希表存储数据，计算键的索引确定位置。
默认情况，不保证存储顺序，java8后，h链表过长会转化为红黑树。

treeMap基于红黑树存储数据，是一种自平衡二叉查找树



# 9.java的集合类有哪些，哪些是线程安全，哪些不是线程安全的？

set
list
map
queue

线程安全：
vector
hashtable
java.util.concurrent包下的类,比如：concurrentHashMap


非线程安全：
ArrayList，LinkedList， HashSet，HashMap，TreeSet，TreeMap





# 10.HashMap为什么是线程不安全的？如何线程安全？

因为它的内部在**多线程并发访问时**，**没有进行线程同步**，所以会出现线程不安全的情况

实现方法：
1.使用**Collections.synchronizedMap()**方法将HashMap包装成线程安全的Map
2.使用线程安全的集合类，如**ConcurrentHashMap**类，就是线程安全的


# 11.Collection接口和Collections类的区别是什么？
Collection接口是java集合框架的**根接口**，定义了**集合的基本操作**，如添加、删除、遍历等
Collections类是java集合框架**的工具类**，提供了一些**静态方法**，如排序、查找、反转等




# 12.Vector和ArrayList的区别？
Vector线程安全，ArrayList非线程安全

性能：
Vector会相对来说较慢，因为它是所有公开方法都是同步的

扩容机制：
Vector默认扩容为原来的2倍
ArrayList默认扩容为原来的1.5倍
































