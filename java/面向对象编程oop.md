# 1.什么是面向对象编程（OOP）？

我的理解是将现实中的食物抽象成为一个对象，然后将特征封装成属性，行为封装成方法

封装，继承，多态

封装：将属性和行为捆绑在一起形成一个独立的单元（类，对象），只提供接口，隐藏实现
继承：子类继承父类的属性和方法，实现代码复用  （单继承，多层继承，传递性，构造器不被继承）
多态：同一个方法，不同的对象有不同的实现，即同一个方法，不同的对象有不同的行为


# 2.类和对象的关系是什么？

类定义了对象的结构和操作，但是没有实际数据，类似一个模具

而对象是根据特定数据例化出来的，对象有具体的数据，类似一个模具实例化出来的对象


# 3.解释java中的封装原则，并给出一个实例。

类似去餐厅吃饭，它提供了菜单（类）
菜单上的菜就是方法，你并不知道具体实现，只知道点了某道菜，就执行了某道菜的实现（返回结果）
这就是封装的精髓，封装了具体的实现，**只提供接口，隐藏实现**

外边的人只知道接口，而不需知道**实现**

封装的原则：
1. 数据隐藏：将对象的内部数据隐藏起来，只提供对外的接口
2. 提高安全性：数据隐藏，避免数据被外部访问，从而提高安全性
3. 简化复杂性：外部只需要知道调用方法，而不需要了解内部的复杂实现

实现：
1.属性私有化
2.提供公共访问方法，getter，setter


# 4.抽象类和接口的区别？

我的理解：abstract修饰的类，不能被实例化，
        即不能通过new来创建对象，常用作对应子类的基类

接口：是完全抽象的类型，用interface来定义
        表示应该具有什么功能，但不进行具体实现
        主要目的就是多重继承：可以被类实现，实现接口的类必须实现接口中的所有方法

抽象类可以定义各种成员变量（实例变量，静态变量） 
        可以拥有构造方法，并支持重构
        可以有抽象方法
而接口不可以有实例变量，构造方法，只有共有静态常量，因此必须在定义时进行初始化
        


适用场景：
抽象类：表示“is-a"关系，作为类族的基类，提供模板方法模式
接口：表示“can-do”或“has-a“关系，定义行为规则/标准，实现多态，弥补单继承的不足



# 5.java中的继承机制如何工作？子类能继承父类哪些内容？

继承机制：子类继承父类的属性和方法，并添加新的属性和方法

子类和父类的关系：通过extends关键字来继承父类，子类自动拥有父类的非私有，静态成员变量和方法
        也就是public和protected修饰的成员变量和方法
        不继承父类的构造方法，静态成员变量和方法，private


# 6.多态性在java中如何实现？

重载
重写


# 7.说一说你对java多态的理解？

事物的多态：例如小猫小狗都是动物这种类型的各种形态
多态的前提是类的**继承**和方法的**重写**
体现了一种**开闭原则**：对扩展开放，对修改关闭
                        

**为什么需要多态？**
好处：父类引用子类的对象不同，调用方法时，会调用子类的方法。
        可以实现方法的动态绑定，即运行时确定调用哪个方法
        提升代码的可拓展性和灵活性

弊端：父类引用子类对象，调用方法时，会调用子类的方法，但是子类没有实现父类的方法，就会发生错误
        父类变量不能访问子类对象中特有的属性和方法




# 8.构造函数的作用是什么？构造方法的重载是如何实现的？

构造函数的作用：在创建对象时，初始化对象的属性
重载



# 9.静态变量和实例变量的区别是什么？静态方法呢？

静态变量：属于类，不属于对象，在内存中只有一份，在类加载时初始化，是共享的
实例变量：属于对象，每个对象都有自己的一份，在创建对象时初始化
静态方法：属于类，不属于对象，在内存中只有一份，在类加载时初始化，
        只能访问静态变量和静态方法，不能访问实例变量和实例方法


# 10.final关键字在java中有哪些用法？

好比你在家里有一张“不可更改的计划表”，这张表上列出了你每天必须做的事情，
比如“吃饭”“学习”“运动”，这些安排都已经写死了，不能随便更改。
而且，如果你跟朋友分享这张表，你们都得遵守一样的安排——谁也不能随便修改它。























































