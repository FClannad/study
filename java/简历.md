# 熟悉Java核心知识，熟悉常用集合及其数据结构，面向对象等
## 集合：
hashmap：
hashmap就是基于键值对来进行存储的一个数组，存储数据采用哈希表的结构 
当链表长度超过8，当链表长度小于6时转为链表；
数组长度超过64会转换为红黑树来进行存储
hashmap是线程不安全的，多线程情况下，容易出现死循环，导致cpu占用率飙升

扩容： 
触发条件就是键值对超过阈值    
一般阈值是容量乘以负载因子（0.75）这是一个在时间和空间成本上的折衷。                 
目的：
减少哈希冲突：
通过扩大数组容量，使得更加均匀的分布，减少哈希冲突，保证查询效率
保持性能：
不扩容的话，链表和红黑树越来越大，性能会下降


hashset：
基于hashmap来进行实现，存储不重复的键值对，底层是HashMap，
所以存储元素是键，值的话是固定的object

HashMap 的工作原理是什么？
基于哈希表，通过 Key 的 hashCode()计算数组下标存储和获取数据，使用链表和红黑树解决哈希冲突。
JDK 1.8 中 HashMap 做了什么优化？
引入了红黑树，当链表长度超过 8 且数组长度大于等于 64 时，将链表转为红黑树，防止查询性能退化。
HashMap 的扩容机制是怎样的？
当元素数量超过 容量 * 负载因子时，容量变为原来的 2 倍。JDK 1.8 优化了重新计算元素新位置的过程。
为什么 HashMap 的长度是 2 的幂次方？
为了高效计算数组下标。通过 (n-1) & hash代替 hash % n，位运算效率远高于取模运算。同时，这个设计也是 JDK 1.8 高效扩容算法的基础。
HashMap 是线程安全的吗？怎么解决？
不是。使用 ConcurrentHashMap。
HashMap 和 Hashtable 的区别？
HashMap 线程不安全，允许 null 键/值；Hashtable 线程安全（方法用 synchronized 修饰），不允许 null 键/值。Hashtable 已过时。

**“HashMap和ConcurrentHashMap的核心区别在于线程安全性。**
HashMap是非线程安全的，它在多线程环境下使用时可能会导致数据错乱或被破坏。
而ConcurrentHashMap是线程安全的，它专门为高并发场景设计，允许多个线程同时安全地进行读写操作。
为了实现这种高效的线程安全，它们的底层实现完全不同：
在JDK 8之后，ConcurrentHashMap采用了 CAS指令和synchronized只锁住单个桶（链表头节点/树根）的精细锁机制，极大降低了锁的粒度，保证了高并发下的性能。
相比之下，老的线程安全容器如Hashtable是直接用synchronized锁住整个对象，性能非常差。
此外，HashMap允许存储Null键和Null值，而ConcurrentHashMap出于并发安全的设计考量，不允许存储任何Null键或Null值。
总结一下就是：在单线程或不需要考虑并发的场景下，用HashMap性能最好；但在多线程并发环境中，ConcurrentHashMap是既安全又高性能的最佳选择。



## 数据结构：
#### 基本数据类型：
整数型：**byte,short,int,long**,
浮点型：**float,double**
字符型：**char**,
布尔型：**boolean**

#### 引用数据类型:
类class,接口interface,数组


                              

## 面向对象
封装：隐藏对象的属性和实现细节，仅对外公开接口，控制程序中数据和函数的访问级别
继承：子类继承父类的属性和方法，子类可以拥有父类的属性和方法，也可以重写父类的方法
抽象：定义抽象类，定义抽象方法，实现抽象方法，继承抽象类，实现抽象方法
多态：父类引用指向子类对象，调用父类方法时，实际执行的是子类方法
单一职责原则： 一个类只负责一项职责。这能提高类的内聚性，降低变更引起的风险。
开闭原则： 对扩展开放，对修改关闭。即应该通过扩展（如继承、实现接口）来增加新功能，而不是修改已有的代码。（你项目中用的适配器模式就是典范！）



# 了解JVM内存区域划分，垃圾回收算法，双亲委派机制
## 内存划分：
**方法区**：用于存储类的结构信息，java8之后改用元空间
用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

**堆**：用于存储对象实例和数组，是垃圾收集器管理的重点区域
分代：
新生代：
Eden区Survivor区
对象刚创建会被分配到这
Eden区满了之后，触发minor gc，将存活的对象复制到Survivor区，然后清空Eden区


                 老年代：
                        存活时间较长的对象会被复制到老年代
老年代满了之后，触发full gc，对老年代进行垃圾回收

**程序计数器**：
当前线程所执行的字节码的行号指示器。
每个线程私有，用于线程切换后恢复执行时使用。
特点： JVM 中唯一一个不会抛出 OOM 的内存区域。


**虚拟机栈**：
管理java调用的运行状态，每个方法调用对应一个栈帧（局部变量表、操作数栈、方法出口等信息）
每个进程私有，生命周期和线程同步。
异常：
StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度
OutOfMemoryError：虚拟机栈无法申请到足够内存

**本地方法栈**：
为native本地方法服务
结构和虚拟机栈一样，只是为了native方法服务
异常：和虚拟机栈一样
![img_13.png](img_13.png)

堆：共享的“公共办公区”。所有new出来的对象都在这儿办公，是GC保洁阿姨主要打扫的区域。
虚拟机栈：每个线程的“私人办公桌”。上面放着当前正在执行的方法（局部变量、操作步骤），方法结束就像清理一次桌面。
程序计数器：桌上的“任务进度便签”。提醒线程当前工作做到哪一步了，防止被打断后找不到北。
方法区：公司的“中央档案室”。存放所有员工的劳动合同（类信息）、公司规章制度（常量）、公共海报（静态变量）。
本地方法栈：专门对接外部供应商的“国际电话亭”。用于执行那些用其他语言（C/C++）写的本地方法。
核心理解：这个划分完美平衡了协作与隔离。“公共办公区（堆）”让大家共享数据，而“私人办公桌（栈）”保证了每个线程独立工作不被打扰，这正是JVM高效运行的关键。


**垃圾回收算法**
可以把JVM的堆内存想象成一个有很多房间的酒店，垃圾回收就是酒店的自动化保洁系统。
分代假说：保洁系统发现，大部分客人（对象）都是短命鬼（朝生暮死），住一晚就走；只有少数是长住客。
            所以把酒店分为新生代（年轻房区）和老年代（长住房区）。
回收算法：
复制算法（用于新生代）：就像把年轻房区的客人集中搬到另一个干净的空房区，然后直接清空原来的整个房区。
                    优点是速度快、没碎片；缺点是总得留出一半空房，有点浪费。
标记-清除：保洁员先标记出所有要打扫的垃圾房间（标记），然后一次性清理（清除）。
            缺点是会产生内存碎片，就像清理后房间散乱，想安排一个旅游团（大对象）就找不到连续的空房。
标记-整理：在标记-清除的基础上，让所有还在住的客人向一端移动，然后直接清理掉另一端的所有房间。
            优点是解决了碎片问题，适合长住房区（老年代）。
一句话总结：JVM通过分代思想，对“短命”的新生代用复制算法快准狠），对“长命”的老年代用标记-整理算法（节约空间），
            自动化地清理内存垃圾，保证酒店（应用）高效运转。

**双亲委派机制**
这就像是公司里下达任务时的“请示汇报流程”，目的是避免重复劳动和越权行事。
流程：当一个员工（应用程序类加载器）接到一个任务（加载一个类的请求），他不会自己直接去做。
他会先问他的直接经理（扩展类加载器）：“这个您能做吗？”经理也不会自己做，
而是继续向上请示大老板（启动类加载器）：“这个您来处理？”。



# 熟悉Redis基本使用，熟悉缓存穿透、击穿、雪崩，分布式锁，高性能原理，哨兵机制，持久化机制等。

**说说你对缓存穿透、击穿、雪崩的理解，以及在实际项目中你是如何应对的？**
首先，一句话概括本质：
“这三者都是缓存失效时，流量直接压垮数据库的异常场景，但诱因和粒度不同。
    穿透是查询不存在的数据，击穿是单个热点Key失效，雪崩是大量Key同时失效。”

然后，分点阐述解决方案与个人理解：
缓存穿透（查无此数据）
解决方案：1）缓存空值并设置短过期时间
        2）使用布隆过滤器在缓存前做一层快速校验。
我的理解：这本质上是防御恶意或异常请求。布隆过滤器用很小的空间代价换取了极高的查询效率，但它是一种概率性数据结构，
        有误判的可能（判断存在可能实际不存在，但判断不存在则一定不存在），这正好适用于拦截“绝对无效”的请求。

缓存击穿（热点Key失效）
解决方案：使用分布式锁（如Redis的SETNX）。
        或者设置热点key永不过期
我的理解：这本质上是解决高并发下的“羊群效应”。核心思路是将并行的负载转为串行，用一把锁保护数据库，
        用暂时的性能牺牲换取整个系统的稳定性。在我的项目中，就是用这个方案保护了“热门体检套餐”这类热点数据。

缓存雪崩（大量Key同时失效）
解决方案：1）给缓存Key的过期时间加上随机值，打散失效时间；
        2）或者设置逻辑过期（Key不过期，后台异步刷新）。
我的理解：这本质上是避免系统出现“共振”。就像安排员工休假要错开，不能同一天都走。
        通过引入随机性，避免了所有压力在同一时刻爆发，让系统负载更加平滑。


**你是怎么用Redis实现分布式锁的？考虑过哪些问题？**













**为什么Redis能这么快？**
Redis的高性能是多种因素共同作用的结果，我认为核心是四点：
内存存储：数据完全放在内存中，避免了磁盘I/O这个最大的速度瓶颈。
高效的数据结构：Redis不仅提供了简单动态字符串、跳跃表等优秀底层数据结构，还对每种数据类型（如Hash、List）都做了精细的优化，比如在数据量小时用压缩列表（ziplist）存储来节省内存。
单线程Reactor模型：这是最精妙的一点。它的网络I/O（请求接收和回复）和数据读写是单线程的。这避免了多线程的上下文切换和竞争锁的开销​​，非常适合操作内存数据的场景。同时，它使用I/O多路复用（epoll）来处理海量的网络连接，一个线程就能高效处理。
优化的网络层：使用了高效的自定义协议，传输紧凑，解析速度快。”



**Redis的持久化机制和哨兵模式分别解决了什么问题？**
先回答持久化（解决数据可靠性）：
“持久化解决的是数据备份和故障恢复问题，防止服务器宕机后数据全部丢失。主要有两种方式：
RDB：在特定时间点生成整个数据的快照。优点是文件紧凑，恢复速度快，适合做灾难备份。缺点是会丢失最后一次快照到宕机期间的数据。
AOF：记录每一次写操作命令。优点是数据可靠性高，最多丢失1秒数据。缺点是文件大，恢复慢。
我的理解：生产环境通常两者都开启。RDB是定期的全量体检，AOF是实时的操作日志。用AOF保证数据不丢，用RDB做快速恢复和备份。”
再回答哨兵（解决高可用）：
“哨兵模式解决的是主从架构下的故障自动转移问题，也就是高可用。它独立于Redis进程，负责监控主节点和从节点。当主节点宕机时，哨兵能自动将一个从节点提升为主节点，并让其他从节点和客户端切换到新主节点。
我的理解：哨兵的本质是一个分布式的主从架构‘管家’集群。
它通过投票机制来达成共识，避免单点故障，实现了服务的‘自愈’能力，但对横向扩展（分片） 无能为力，
那是Redis Cluster要解决的问题。”

# 熟悉MySQL数据库，熟练使用sql，熟悉索引，事务隔离级别，MVCC，了解锁机制，sql优化；


