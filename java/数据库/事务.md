
# 事务的四大特性：

原子性：事务是一个不可分割的工作单位，事务中的所有操作都成功，或者都失败。 undolog

隔离性：多个事务之间不能互相干扰。 锁

持久性：事务执行完成之后，结果会持久化到数据库中。 redolog

一致性：事务执行之前和执行之后，数据库的完整性没有被破坏。

![img_3.png](img_3.png)
锁保证隔离
redo log保证持久性
undo log保证原子性
mvcc隔离性加提高并发

![img_2.png](img_2.png)


# 事务隔离等级：

读未提交：最低级别：一个事务可以读取到另一个事务未提交的数据；
        存在脏读，幻读，不可重复读


读提交：只能读取到已经提交的数据，不能读取到未提交的数据；
        存在不可重复读

重复读：重复相同的查询，结果一致
        存在幻读


串行化：会对记录进行加读写锁，发生读写冲突时，会阻塞


# sql调优

慢日志 ：show variables like '**slow_query_log**' + explain 先查问题
覆盖索引+最左匹配 
别*号、别函数、别前置百分号
排序与联表要有索引且字符集统一

![img_4.png](img_4.png)



# 并行事务会出现什么问题

脏读：一个事物读取到了其他事务未进行提交的数据

不可重复读：前后读取的数据不一样

幻读：一个事务插入了数据，但是其他事务也插入了数据，导致数据重复



# 锁等待和死锁？如何处理?
锁等待：就是一个线程要获取锁，但是锁被其他线程占用，导致等待

死锁：两个线程都获得了锁，都在等对方进行释放，导致两个线程都处于等待状态

锁等待处理：设置超时

死锁处理：mysql会自动检测死锁，并释放锁
        要合理设计进行预防死锁



# 并发控制和事务管理？

并发控制：确保多个事务并行执行时，能够保持数据库的正确性和一致性。
        常用锁机制和隔离级别

事务管理：确保数据库的操作是原子的，要么全部执行成功，要么全部执行失败。
        常用事务的四大特性：原子性，一致性，隔离性，持久性



# 幻读如何进行解决？
幻读：一个事务插入了数据，但是其他事务也插入了数据，导致数据重复
        针对快照读：通过MVCC机制来解决幻读
        针对当前读（select * for update）：
                通过(next-key lock)记录锁加间隙锁，解决幻读
        因为当执行select * for update时，会加锁，
        导致其他事务不能进行读操作，从而解决幻读



# 读已提交是如何实现？
通过MVCC机制来实现：
        读操作：在mvcc中，每个事务都会读到数据的一个版本。
                已提交的事务产生一个版本，未提交一个版本。
                读提交就是确保读到数据是已提交的
        写操作：创建一个新的数据版本，而不是直接修改原始数据。
                        确保了正在进行的事务不会看到没有提交的数据。































