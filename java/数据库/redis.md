

# 优缺点？
优点：
    基于内存快
    数据结构丰富
    持久化
    分布式支持：支持集群部署，具有高可用性。

缺点：
    内存消耗大
    持久化有限
    不适合复杂查询


# 是什么？特点？
Redis是一个开源的基于内存的数据库，
    读写速度非常快，通常被用作缓存、消息队列、分布式锁和键值存储数据库。

特点：
基于内存
持久化：        它可以通过将数据持久化到磁盘上的快照和日志文件来保证数据的持久性，
                以防止数据丢失。
多数据结构：
原子性操作
分布式


# 为什么使用redis而不只用MySQL？

redis具有**高性能**以及**高并发**





# redis是单线程吗？

是单线程的，但是指的是**网络请求模块使用单线程进行处理，其他模块仍使用多线程**，
    redis程序并不是单线程的，在启动时会启动后台线程。

        Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理




# redis数据类型有哪些？使用场景？

1. 字符串(String)
    底层数据结构是SDS（简单动态字符串）
    使用场景：缓存对象
            计数
            分布式锁
            共享session数据
2. 哈希(Hash)
    底层是由双向链表或压缩列表实现
    使用场景：缓存对象、购物车
3. 列表(List)
    底层是由双向链表或压缩列表实现
    使用场景：朋友圈顺序点赞、消息队列（左进右出实现队列设计）
4. 集合(Set)
    底层是由哈希表或整数集合实现
    使用场景：共同关注（key,value）（用户id，公众号id）
5. 有序集合（Zset）
    底层是由跳跃表或压缩列表实现
    使用场景：排行榜（key，score）数据更新频繁或者需要分页显示
6. bitmap
7. HyperLoglog
8. GEO
9. Stream





# 主从复制的同步过程

1.建立连接：节点向主节点发送SYNC命令请求简历连接。
2.主节点创建RDB快照：（初次）主节点会执行BGSAVE命令，
    创建一个RDB快照，将当前内存数据保存到一个文件中
3.主节点发送RDB和AOF缓冲区内容：
    主节点将RDB快照文件和AOF缓冲区的内容发送给从节点。

4.从节点载入RDB文件和执行AOF缓冲区命令


## 避免主从数据的不一致
持久化和复制配置：确保启用了持久化配置（RDB快照AOF文件）和复制配置
保证网络稳定
监控和报警

## 增量复制：
初次同步完成，从节点就会转入增量复制的阶段。主节点会实时将写入的命令发送给从节点
从节点接受并执行这些命令，保持和主节点的数据一致

## 心跳和命令传播
主节点和从节点之间会定期进行心跳检测，以确保连接的稳定性。



# 哨兵机制
哨兵机制是Redis高可用的一种解决方案，它通过监控主节点的状态，
并在主节点发生故障时自动进行故障转移，从而保证Redis服务的可用性。



# Redis切片集群的工作原理

当Redis缓存数据量过大时，会进行切片，将数据进行分片存储，
    大到一个服务器无法缓存时，就需要用Redis切片集群
    将数据分布到不同的服务器上，以此来降低系统对单节点的依赖，从而提高Redis服务的读写性能


# **内存淘汰机制**
-- 不进行数据淘汰
-- NoEviction：如果内存不足以执行写操作，Redis将返回错误，默认的淘汰策略
-- VolatitleTTL：优先淘汰更早过期的键值
-- VolatitleLRU:只对带有过期时间的键使用LRU策略，其他键使用NoEviction策略
-- VolatitleRandom:随机淘汰带有过期时间的键
-- VolatitleLFU：只对带有过期时间的键使用LFU策略，其他键使用NoEviction策略
-- AllKeysLRU：对所有键使用LRU策略
-- AllKeysRandom：随机淘汰所有键
-- AllKeysLFU：对所有键使用LFU策略

可以使用config get maxmemory-policy命令查看当前Redis实例使用的内存淘汰策略。
使用config set maxmemory-policy命令设置内存淘汰策略。




# Redis的LRU算法和LFU算法

LRU算法：最近最少使用算法，即最近使用的数据被优先处理，

LFU算法：最不经常使用算法，即使用频率最低的数据被优先处理。





# 如何保证删除缓存操作一定能成功？

重试机制：
    引入消息队列：
在删除缓存操作失败时，重新读取并进行删除，这个就是重试机制

订阅BINLog：
    订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除。





# 持久化机制有哪些？
    RDB快照：将某一时刻的内存数据。以二进制文件保存到磁盘上，
        当需要恢复数据时，会从RDB文件中加载数据。
    AOF日志：将所有的命令记录下来，当需要恢复数据时，会从AOF文件中加载数据。

    混合持久化：将RDB快照和AOF日志混合持久化，
        

# 为什么要引入多线程

因为redis的瓶颈不在内存，而是在网络IO模块带来cpu的耗时，所以redis6.0引入了多线程，
    使用多线程来处理网络请求，从而提高Redis的性能。



# redis类型数据：
1.String：字符串类型 基于SDS简单动态字符串
2.List：存储有序的字符串元素列表
3.Hash：存储键值对
4.Set：存储无序的字符串元素集合
5.Zset：存储有序的字符串元素集合，每个元素关联一个分数
6.BitMap：位图，用于存储二进制数据
7.HyperLogLog：用于存储基数（不重复元素的数量）
8.Geo：用于存储地理位置信息
9.Stream：用于存储有序的消息流


# redis数据类型应用场景：
1.String：缓存、计数器、分布式锁、共享session
2.List：消息队列、朋友圈顺序点赞
3.Hash：缓存对象、购物车
4.Set：共同关注、点赞、标签
5.Zset：排行榜、分数排序
6.BitMap：IP去重、用户行为统计
7.HyperLogLog：基数统计
8.Geo：地理位置信息
9.Stream：消息队列




# Redis底层使用了什么数据结构
SDS
双向链表
压缩列表
哈希表
整数集合
跳表
quicklist：双向链表加压缩列表
listpack：没有压缩列表中记录前一个节点长度的字段，
    listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，
    不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。



# Redis与MySQL的区别是什么
基于内存的数据库，基于磁盘的数据库
基于键值对的数据库，基于关系数据库
Redis不使用sql，使用自己的命令集；MySQL使用sql
Redis以高性能和低延迟为目标，适用于读多写少；
    MySQL适用于需要支持复杂查询、事务处理、拥有大规模数据集的场景


# Redis实现分布式锁

使用SETNX命令，只有插入的key不存在才插入，如果key已经存在，则返回0
解锁的过程就是将key删除，保证执行操作的客户端就是加锁的客户端
    加锁时候要设置unique_value，解锁的时候要验证unique_value是否一致


# Redis事务？

在Redis中，事务是一组命令的有序执行序列，它们被一起执行，而在执行期间不会被其他客户端访问。
    Redis使用MULTI和EXEC命令来执行事务

MULTI：开始一个事务，标记事务的开始
MULTI命令开始一个事务
EXEC命令执行事务


# 缓存中的热点数据和冷数据？
热数据：数据被频繁访问的数据
冷数据：数据被 infrequently 访问的数据



# Redis的集群模式有哪些？
主从复制
哨兵
切片集群



# 缓存雪崩、击穿、穿透 以及 解决办法？

缓存雪崩：就是指在某个时间点，大量缓存同时失效，
    导致请求直接访问数据库或其他后端系统，增加了系统的负载

解决：通过合理设置缓存过期时间，避免缓存同时失效
    或者使用永不过期的策略，在结合定期更新缓存


缓存击穿：就是指在某个时间点，大量请求同时访问同一个缓存，
     缓存中不存在但是数据库中存在数据，导致缓存击穿，直接访问数据库

解决：使用分布式锁，在缓存中不存在时，使用锁进行加锁
        或者在查询数据库前先检查缓存是否存在，如果不存在在允许访问数据库

缓存穿透：指查询一个在缓存和数据库都不存在的数据
        因为都不存在无法被缓存，导致直接访问数据库，增加负载

解决：采用布隆过滤器等手段来过滤掉恶意请求，或者在查询数据库前先进行参数的合法性校验




# 过期删除策略？
定时删除：设置key的过期时间
惰性删除：当键被访问时，如果键已经过期，则删除键
定期删除：定期抽查数据库，删除过期的键








