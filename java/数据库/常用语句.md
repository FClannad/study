
# 数据查询

select * from table_name
select A, B from table_name
select * from table_name where A = 'a'

排序： order by Age desc
去重： select distinct A from table_name
分页： select * from table_name limit 10 offset 20
别名： select A as B from table_name
模糊查询： select * from table_name where A like '%a%'
范围查询： select * from table_name where A between 1 and 10
多条件： select * from table_name where A = 'a' and B = 'b'



# 多表操作

内连接： SELECT u.name, o.amount FROM users u JOIN orders o ON u.id = o.user_id;
左连接： select u.name, o.amount from users u left join oreder o on u.id = o.user_id;
右连接： select u.name, o.amount from users u right join oreder o on u.id = o.user_id;
子查询： select name from users where id in (select user_id from orders);
子查询（from）:
select u.id , count(*) from (select * from users where age > 18) u group by u.id


# 聚合与分组
聚合函数： count, max, min, avg, sum
分组： select A, count(*) from table_name group by A
分组条件： select A, count(*) from table_name group by A having count(*) > 10


# 数据更新和写入

插入： insert into table_name (A, B) values ('a', 'b')
批量插入： insert into table_name (A, B) values ('a', 'b'), ('c', 'd')

插入或更新： insert into table_name (A, B) values ('a', 'b') on duplicate key update B = 'b'
更新：update table_name set A = 'a' where B = 'b'
删除：delete from table_name where A = 'a'


# 索引与性能优化

查看索引： show index from table_name
创建索引： create index index_name on table_name (A)
删除索引： drop index index_name on table_name
使用执行计划：explain select * from users where age > 18
查看慢查询日志： show variables like 'slow_query_log'
强制使用索引：select * from users force index (idx_age) where age > 18


# 事务与锁操作

开启事务： begin;
提交事务： commit;
回滚事务： rollback
设置隔离等级： set session transaction isolation level repeatable read
查看当前隔离等级： select @@tx_isolation


悲观锁： select * from users where id = 1 for update
悲观锁的实现原理是：在查询数据时，将数据行锁定，
（我的理解就是先对行，即要操作的数据进行锁定，然后再进行操作）

乐观锁：update users set age = 26 ， version = version + 1 
        where id = 1 and version = 2
而乐观锁的实现原理是：在更新数据时，先查询出数据，
然后判断数据版本是否一致，如果一致则更新数据，否则返回错误。


# 面试高频场景题
查询每个用户的最后一笔订单：
select max(order_id) from orders group by user_id
或者：
select user_id, order_id from orders o1 
where o1.order_id = (select max(o2.order_id) 
from orders o2 where o1.user_id = o2.user_id)


查询重复的数据：
select name ， count（*）
from users
group by id
having count(*) > 1


查询某字段为空
select phone 
from users 
where phone is null



查询某天注册的用户：
select name 
from users
where date(create_time) = '2021-01-01'


分页优化：
select * 
from users
where id > ? limit 10
替代 OFFSET

